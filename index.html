<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adaptive GPS Compass Navigator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            max-width: 500px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 25px;
            font-size: 24px;
        }

        .input-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            color: #555;
            font-weight: 500;
            font-size: 14px;
        }

        input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        input:focus {
            outline: none;
            border-color: #667eea;
        }

        .button-group {
            margin: 20px 0;
            display: flex;
            gap: 10px;
        }

        button {
            flex: 1;
            padding: 14px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #startBtn {
            background: #667eea;
            color: white;
        }

        #startBtn:hover:not(:disabled) {
            background: #5568d3;
            transform: translateY(-2px);
        }

        #stopBtn {
            background: #ef4444;
            color: white;
        }

        #stopBtn:hover:not(:disabled) {
            background: #dc2626;
            transform: translateY(-2px);
        }

        .message {
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
            text-align: center;
            font-size: 14px;
        }

        .message.error {
            background: #fee2e2;
            color: #991b1b;
            border: 1px solid #fecaca;
        }

        .message.warning {
            background: #fef3c7;
            color: #92400e;
            border: 1px solid #fde68a;
        }

        .message.info {
            background: #dbeafe;
            color: #1e40af;
            border: 1px solid #bfdbfe;
        }

        .message.success {
            background: #d1fae5;
            color: #065f46;
            border: 1px solid #a7f3d0;
        }

        .cta-button {
            display: inline-block;
            margin-top: 8px;
            padding: 8px 16px;
            background: #667eea;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
        }

        .cta-button:hover {
            background: #5568d3;
        }

        .distance-display {
            text-align: center;
            margin: 25px 0;
            padding: 20px;
            background: #f9fafb;
            border-radius: 12px;
        }

        .distance-label {
            color: #6b7280;
            font-size: 14px;
            margin-bottom: 5px;
        }

        .distance-value {
            font-size: 36px;
            font-weight: 700;
            color: #667eea;
        }

        .compass-container {
            position: relative;
            width: 280px;
            height: 280px;
            margin: 30px auto;
        }

        .compass-circle {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: linear-gradient(135deg, #f0f0f0 0%, #e0e0e0 100%);
            box-shadow: inset 0 4px 8px rgba(0,0,0,0.1), 0 4px 12px rgba(0,0,0,0.15);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .compass-directions {
            position: absolute;
            width: 100%;
            height: 100%;
        }

        .direction-label {
            position: absolute;
            font-weight: 700;
            font-size: 18px;
            color: #333;
        }

        .direction-label.n { top: 10px; left: 50%; transform: translateX(-50%); }
        .direction-label.e { right: 15px; top: 50%; transform: translateY(-50%); }
        .direction-label.s { bottom: 10px; left: 50%; transform: translateX(-50%); }
        .direction-label.w { left: 15px; top: 50%; transform: translateY(-50%); }

        .needle {
            position: absolute;
            width: 6px;
            height: 120px;
            background: linear-gradient(to bottom, #ef4444 0%, #ef4444 50%, #6b7280 50%, #6b7280 100%);
            border-radius: 3px;
            top: 50%;
            left: 50%;
            transform-origin: center 60px;
            transform: translate(-50%, -60px) rotate(0deg);
            transition: transform 0.1s linear;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .needle::before {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background: #333;
            border-radius: 50%;
            top: 52px;
            left: 50%;
            transform: translateX(-50%);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .status-text {
            text-align: center;
            margin-top: 15px;
            font-size: 14px;
            color: #6b7280;
            font-style: italic;
        }

        @media (max-width: 600px) {
            .container {
                padding: 20px;
            }

            h1 {
                font-size: 20px;
            }

            .compass-container {
                width: 240px;
                height: 240px;
            }

            .needle {
                height: 100px;
                transform-origin: center 50px;
                transform: translate(-50%, -50px) rotate(0deg);
            }

            .distance-value {
                font-size: 28px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ§­ Adaptive GPS Compass Navigator</h1>

        <div id="messageBox"></div>

        <div class="input-group">
            <label for="destLat">Destination Latitude</label>
            <input type="number" id="destLat" step="any" placeholder="e.g., 40.7128">
        </div>

        <div class="input-group">
            <label for="destLng">Destination Longitude</label>
            <input type="number" id="destLng" step="any" placeholder="e.g., -74.0060">
        </div>

        <div class="button-group">
            <button id="startBtn">Start Navigation</button>
            <button id="stopBtn" disabled>Stop Navigation</button>
        </div>

        <div class="distance-display">
            <div class="distance-label">Distance to Destination</div>
            <div class="distance-value" id="distanceValue">---</div>
        </div>

        <div class="compass-container">
            <div class="compass-circle">
                <div class="compass-directions">
                    <div class="direction-label n">N</div>
                    <div class="direction-label e">E</div>
                    <div class="direction-label s">S</div>
                    <div class="direction-label w">W</div>
                </div>
                <div class="needle" id="needle"></div>
            </div>
        </div>

        <div class="status-text" id="statusText">Enter destination coordinates to begin</div>
    </div>

    <script>
        // State management
        const state = {
            isNavigating: false,
            phase: 1, // 1 = compass calibration, 2 = GPS adaptive
            phaseStartTime: null,
            destination: { lat: null, lng: null },
            currentLocation: { lat: null, lng: null },
            watchId: null,
            orientationActive: false,
            needleRotation: 0,
            smoothHeading: 0,
            gpsHistory: [], // { lat, lng, time, dist, accuracy }
            smoothDistance: null,
            arrived: false
        };

        // DOM elements
        const elements = {
            destLat: document.getElementById('destLat'),
            destLng: document.getElementById('destLng'),
            startBtn: document.getElementById('startBtn'),
            stopBtn: document.getElementById('stopBtn'),
            messageBox: document.getElementById('messageBox'),
            distanceValue: document.getElementById('distanceValue'),
            statusText: document.getElementById('statusText'),
            needle: document.getElementById('needle')
        };

        // Initialize
        checkHTTPS();
        checkLocationPermission();

        // HTTPS gate
        function checkHTTPS() {
            if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
                showMessage('This app requires HTTPS to access location and compass permissions.', 'error');
                elements.startBtn.disabled = true;
            }
        }

        // Location permission gate
        async function checkLocationPermission() {
            if ('permissions' in navigator) {
                try {
                    const result = await navigator.permissions.query({ name: 'geolocation' });
                    if (result.state === 'granted') {
                        elements.startBtn.disabled = false;
                    } else if (result.state === 'prompt') {
                        showLocationPermissionPrompt();
                    } else {
                        showLocationDenied();
                    }
                } catch (e) {
                    showLocationPermissionPrompt();
                }
            } else {
                showLocationPermissionPrompt();
            }
        }

        function showLocationPermissionPrompt() {
            elements.startBtn.disabled = true;
            showMessage(
                'Location permission is required to navigate.<br><span class="cta-button" onclick="requestLocationPermission()">Enable Location</span>',
                'warning'
            );
        }

        function showLocationDenied() {
            elements.startBtn.disabled = true;
            showMessage(
                'Location access denied. Please enable location permissions in your browser settings.<br><span class="cta-button" onclick="requestLocationPermission()">Retry</span>',
                'error'
            );
        }

        function requestLocationPermission() {
            navigator.geolocation.getCurrentPosition(
                () => {
                    elements.startBtn.disabled = false;
                    showMessage('Location permission granted!', 'success');
                    setTimeout(() => elements.messageBox.innerHTML = '', 2000);
                },
                () => {
                    showLocationDenied();
                }
            );
        }

        function showMessage(msg, type) {
            elements.messageBox.innerHTML = `<div class="message ${type}">${msg}</div>`;
        }

        // Haversine distance in meters
        function haversineDistance(lat1, lng1, lat2, lng2) {
            const R = 6371000; // Earth radius in meters
            const Ï†1 = lat1 * Math.PI / 180;
            const Ï†2 = lat2 * Math.PI / 180;
            const Î”Ï† = (lat2 - lat1) * Math.PI / 180;
            const Î”Î» = (lng2 - lng1) * Math.PI / 180;

            const a = Math.sin(Î”Ï†/2) * Math.sin(Î”Ï†/2) +
                      Math.cos(Ï†1) * Math.cos(Ï†2) *
                      Math.sin(Î”Î»/2) * Math.sin(Î”Î»/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

            return R * c;
        }

        // Bearing from point A to point B (0-360)
        function bearing(lat1, lng1, lat2, lng2) {
            const Ï†1 = lat1 * Math.PI / 180;
            const Ï†2 = lat2 * Math.PI / 180;
            const Î”Î» = (lng2 - lng1) * Math.PI / 180;

            const y = Math.sin(Î”Î») * Math.cos(Ï†2);
            const x = Math.cos(Ï†1) * Math.sin(Ï†2) -
                      Math.sin(Ï†1) * Math.cos(Ï†2) * Math.cos(Î”Î»);
            const Î¸ = Math.atan2(y, x);
            return (Î¸ * 180 / Math.PI + 360) % 360;
        }

        // Normalize angle to 0-360
        function normalize360(angle) {
            return ((angle % 360) + 360) % 360;
        }

        // Smallest angle difference (-180 to 180)
        function smallestAngleDiff(a, b) {
            let diff = a - b;
            diff = ((diff + 180) % 360) - 180;
            return diff < -180 ? diff + 360 : diff;
        }

        // Exponential smoothing for circular angles
        function smoothAngle(prev, current, alpha) {
            const diff = smallestAngleDiff(current, prev);
            return normalize360(prev + alpha * diff);
        }

        // Format distance
        function formatDistance(meters) {
            if (meters >= 1000) {
                return (meters / 1000).toFixed(1) + ' km';
            }
            return Math.round(meters) + ' m';
        }

        // Start navigation
        elements.startBtn.addEventListener('click', () => {
            const destLat = parseFloat(elements.destLat.value);
            const destLng = parseFloat(elements.destLng.value);

            if (isNaN(destLat) || isNaN(destLng)) {
                showMessage('Please enter valid coordinates', 'error');
                return;
            }

            state.destination = { lat: destLat, lng: destLng };
            state.isNavigating = true;
            state.phase = 1;
            state.phaseStartTime = Date.now();
            state.gpsHistory = [];
            state.smoothDistance = null;
            state.arrived = false;

            elements.startBtn.disabled = true;
            elements.stopBtn.disabled = false;
            elements.destLat.disabled = true;
            elements.destLng.disabled = true;

            showMessage('Starting navigation...', 'info');
            elements.statusText.textContent = 'Calibrating compass... walk a few steps.';

            startGPSWatch();
            startOrientationListener();

            // Phase transition after 10 seconds
            setTimeout(() => {
                if (state.isNavigating) {
                    state.phase = 2;
                    stopOrientationListener();
                    elements.statusText.textContent = 'GPS navigation active';
                }
            }, 10000);
        });

        // Stop navigation
        elements.stopBtn.addEventListener('click', () => {
            stopNavigation();
        });

        function stopNavigation() {
            state.isNavigating = false;
            stopGPSWatch();
            stopOrientationListener();

            elements.startBtn.disabled = false;
            elements.stopBtn.disabled = true;
            elements.destLat.disabled = false;
            elements.destLng.disabled = false;

            elements.distanceValue.textContent = '---';
            elements.statusText.textContent = 'Navigation stopped';
            elements.messageBox.innerHTML = '';
        }

        // GPS watch
        function startGPSWatch() {
            if (navigator.geolocation) {
                state.watchId = navigator.geolocation.watchPosition(
                    handleGPSUpdate,
                    handleGPSError,
                    { enableHighAccuracy: true, maximumAge: 0, timeout: 5000 }
                );
            }
        }

        function stopGPSWatch() {
            if (state.watchId !== null) {
                navigator.geolocation.clearWatch(state.watchId);
                state.watchId = null;
            }
        }

        function handleGPSUpdate(position) {
            if (!state.isNavigating) return;

            const { latitude, longitude, accuracy } = position.coords;
            state.currentLocation = { lat: latitude, lng: longitude };

            const dist = haversineDistance(
                latitude, longitude,
                state.destination.lat, state.destination.lng
            );

            // Add to history (keep last 12 samples)
            state.gpsHistory.push({
                lat: latitude,
                lng: longitude,
                time: Date.now(),
                dist: dist,
                accuracy: accuracy || 10
            });

            if (state.gpsHistory.length > 12) {
                state.gpsHistory.shift();
            }

            // Smooth distance
            if (state.smoothDistance === null) {
                state.smoothDistance = dist;
            } else {
                state.smoothDistance += 0.2 * (dist - state.smoothDistance);
            }

            // Update distance display
            elements.distanceValue.textContent = formatDistance(state.smoothDistance);

            // Check arrival
            if (dist < 15 && !state.arrived) {
                state.arrived = true;
                elements.statusText.textContent = "You've arrived âœ…";
                showMessage("You've arrived at your destination!", 'success');
            }

            // Phase 2 logic
            if (state.phase === 2) {
                updatePhase2Needle();
            }
        }

        function handleGPSError(error) {
            console.error('GPS error:', error);
            showMessage('GPS error: ' + error.message, 'error');
        }

        // Phase 1: Orientation-based compass
        function startOrientationListener() {
            if (window.DeviceOrientationEvent) {
                state.orientationActive = true;
                window.addEventListener('deviceorientation', handleOrientation);

                // Request permission on iOS 13+
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    DeviceOrientationEvent.requestPermission()
                        .then(permissionState => {
                            if (permissionState !== 'granted') {
                                showMessage('Compass permission denied', 'warning');
                            }
                        })
                        .catch(console.error);
                }
            }
        }

        function stopOrientationListener() {
            state.orientationActive = false;
            window.removeEventListener('deviceorientation', handleOrientation);
        }

        function handleOrientation(event) {
            if (!state.isNavigating || state.phase !== 1 || !state.currentLocation.lat) return;

            let heading;

            // iOS: webkitCompassHeading
            if (event.webkitCompassHeading !== undefined) {
                heading = event.webkitCompassHeading;
            }
            // Android: 360 - alpha
            else if (event.alpha !== null) {
                heading = 360 - event.alpha;
            } else {
                return;
            }

            // Smooth heading
            if (state.smoothHeading === 0) {
                state.smoothHeading = heading;
            } else {
                state.smoothHeading = smoothAngle(state.smoothHeading, heading, 0.2);
            }

            // Calculate bearing to destination
            const bearingToDest = bearing(
                state.currentLocation.lat, state.currentLocation.lng,
                state.destination.lat, state.destination.lng
            );

            // Needle rotation
            state.needleRotation = normalize360(bearingToDest - state.smoothHeading);
            updateNeedleVisual();
        }

        // Phase 2: GPS adaptive needle
        function updatePhase2Needle() {
            if (state.gpsHistory.length < 2) return;

            const current = state.gpsHistory[state.gpsHistory.length - 1];
            const prev = state.gpsHistory[state.gpsHistory.length - 2];

            // Detect movement (speed < 0.6 m/s = standing still)
            const timeDiff = (current.time - prev.time) / 1000; // seconds
            const distance = haversineDistance(prev.lat, prev.lng, current.lat, current.lng);
            const speed = distance / timeDiff;

            if (speed < 0.6) {
                // Standing still - freeze needle
                return;
            }

            // Movement bearing
            const movementBearing = bearing(prev.lat, prev.lng, current.lat, current.lng);

            // Bearing to destination
            const bearingToDest = bearing(
                current.lat, current.lng,
                state.destination.lat, state.destination.lng
            );

            // Delta angle
            const delta = smallestAngleDiff(movementBearing, bearingToDest);

            // Distance trend (compare current to 5 seconds ago)
            const fiveSecsAgo = state.gpsHistory.find(p => (current.time - p.time) >= 5000);
            let targetRotation = state.needleRotation;

            if (fiveSecsAgo) {
                const distChange = current.dist - fiveSecsAgo.dist;
                const threshold = Math.max(6, current.accuracy * 0.6);

                // Case A: Correct movement
                if (distChange < -threshold && Math.abs(delta) < 60) {
                    targetRotation = 0; // Stabilize forward
                }
                // Case B: Wrong direction
                else if (distChange > threshold) {
                    if (Math.abs(delta) > 120) {
                        targetRotation = 180; // Turn back
                    } else {
                        targetRotation = delta;
                    }
                }
                // Case C: Sideways drift
                else if (Math.abs(delta) >= 60 && Math.abs(delta) <= 135) {
                    targetRotation = delta;
                }
            } else {
                targetRotation = delta;
            }

            // Smooth rotation (cap max change per update)
            const rotDiff = smallestAngleDiff(targetRotation, state.needleRotation);
            const maxChange = 8; // degrees
            const clampedDiff = Math.max(-maxChange, Math.min(maxChange, rotDiff));
            state.needleRotation = normalize360(state.needleRotation + clampedDiff);

            updateNeedleVisual();
        }

        // Update needle visual
        function updateNeedleVisual() {
            elements.needle.style.transform = 
                `translate(-50%, -60px) rotate(${state.needleRotation}deg)`;
        }

        // Animation loop for smooth needle updates
        function animationLoop() {
            if (state.isNavigating) {
                updateNeedleVisual();
            }
            requestAnimationFrame(animationLoop);
        }

        animationLoop();
    </script>
</body>
</html>